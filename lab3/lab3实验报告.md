# Lab3：缺页异常和页面置换
## 2213781 宋宣昊  2210554 刘志威   2212850 王海鹏
### 练习1：理解基于FIFO的页面替换算法（思考题）
描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？（为了方便同学们完成练习，所以实际上我们的项目代码和实验指导的还是略有不同，例如我们将FIFO页面置换算法头文件的大部分代码放在了`kern/mm/swap_fifo.c`文件中，这点请同学们注意）
 - 至少正确指出10个不同的函数分别做了什么？如果少于10个将酌情给分。我们认为只要函数原型不同，就算两个不同的函数。要求指出对执行过程有实际影响,删去后会导致输出结果不同的函数（例如assert）而不是cprintf这样的函数。如果你选择的函数不能完整地体现”从换入到换出“的过程，比如10个函数都是页面换入的时候调用的，或者解释功能的时候只解释了这10个函数在页面换入时的功能，那么也会扣除一定的分数

#### 回答：

- **do_pgfault()**

 调用该函数处理页面错误，并传入三个参数分别标识一个页表，错误原因，错误地址。
  
- **assert()**

  判断每一步执行过程是否正确，确保页面换入换出操作无误。
  
- **find_vma()**

  判断访问出错的虚拟地址是否在该页表的**合法虚拟地址集合（所有可用的虚拟地址/虚拟页的集合，不论当前这个虚拟地址对应的页在内存上还是在硬盘上）**里。如果在则mm->mmap_cache = vma。


- **get_pte()**

  获取该vma对应的页表项。**其函数中包含了两种处理即查找和分配的合并，**即依次判断，一级页目录项，二级页目录项，若不存在则分配新的项给这些部分，最后返回页表项。

- **pgdir_alloc_page()**

  **若找到的页表项是0，说明是刚刚创建的页表项。**之前不存在该la和pa的映射关系，调用该函数建立映射。

  - **pgdir_alloc_page()-->alloc_page()**

    进入循环，分配物理页成功则返回分配的物理页失败说明内存不够将页面换出。

- **swap out()**

  选择合适的方法找到要换出页面（如fifo）然后将该页面写入磁盘。成功释放页面失败将页面重新加入交换队列。

- **swapfs_write()**

  把要换出页面的内容保存到硬盘中。

- **map_swappable()-->_fifo_map_swappable**

  将页面加入可交换队列

- **list_add()**

  将新的页面插入队列中head指针的后面。

- **free_page()**

  释放页面

- **tlb_invalidate()**

  刷新TLB

- **swap_out_victim()  --> _fifo_swap_out_victim()**

  该函数使用了FIFO页面置换算法，在swap out()中被调用，获取要被换出的页面。

- **page_insert()**

  **将页面和la，建立映射，插入新的页表项，**会刷新TLB。

- **swap in()**

  若找到页表项不是0，说明之前有映射关系，但是对应的物理页被换出，现在需要换入。

- **swapfs_read()**

  **调用内存和硬盘的I/O接口，读取硬盘中相应的内容到一个内存的物理页，实现换入过程。**底层实现是将内核的一部分内存当成了硬盘空间，然后模仿硬盘每次读取只能分区读取的方式，调用了ide_read_secs()使用memcpy将内存在内核和物理内存之间复制。

- **swap_map_swappable()**

  把页面加入到交换页队列中。

- **le2page()**

  通过链表节点le快速找到其所属的 page 结构体

- **le2vma()**

  通过链表节点le快速找到其所属的 vma_struct 结构体
### 练习2：深入理解不同分页模式的工作原理（思考题）
get_pte()函数（位于`kern/mm/pmm.c`）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
 - get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
 - 目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

#### 相似代码
- 第一段代码处理页目录表的查找与创建。如果对应的页目录项（PDE）不存在，就分配一个新的物理页作为页表，并初始化这个页表。
- 第二段代码处理页表的查找与创建。如果对应的页表项（PTE）不存在，同样分配一个新的物理页作为页面，并初始化这个页面。

#### 多级页表结构
 
在分页机制中，无论是 SV32、SV39 还是 SV48，都采用了多级页表结构来管理虚拟地址到物理地址的映射。这种结构使得页表的管理更加灵活和高效。
 
- **SV32**：
  - 使用**两级页表**：
    - 页目录表（Page Directory Table，PDT）
    - 页表（Page Table，PT）
 
- **SV39**：
  - 使用**三级页表**：
    - 页目录表（Page Directory Table，PDT）
    - 页中间目录表（Page Middle Directory，PMD）
    - 页表（Page Table，PT）
 
- **SV48**：
  - 使用**四级页表**：
    - 页目录指针表（Page Directory Pointer Table，PDPT）
    - 页目录表（Page Directory Table，PDT）
    - 页中间目录表（Page Middle Directory，PMD）
    - 页表（Page Table，PT）
 
尽管这些分页机制的级数不同，但每一级页表的作用和基本操作是相似的。具体来说，就是根据虚拟地址的某一部分（如页目录索引 PDX）来索引页表项。如果该页表项不存在（即未设置有效位 PTE_V），则需要分配一个新的物理页来存储下一级页表，并更新当前页表项以指向新分配的页表。
 
因此，在 `get_pte()` 函数中，这两段代码的相似，是因为它们都在执行相同的操作：检查页表项是否存在，如果不存在则创建它，并初始化相应的物理页或页表。

#### 将页表项的查找和分配合并在一个函数中的设计

##### 优点
 
- **简化接口**：
  - 用户仅需调用一个函数，即可实现页表项的查找或创建，无需深入了解函数内部的具体实现细节。
 
- **代码紧凑**：
  - 将查找与分配的相关功能整合在一个函数中，减少了函数调用的开销，有助于提升代码的执行效率。
 
##### 缺点
 
- **功能耦合**：
  - 查找与分配功能紧密交织，使得函数在维护和扩展时面临挑战。例如，当用户仅需查找页表项而无需创建，或仅需创建页表项而无需查找时，这种设计显得缺乏灵活性。
 
 
##### 是否有必要拆分？
 
在访问页表项的过程中，操作系统必须验证其有效性，如果发现某一级页表还没有被分配，则需要触发分配操作。这两个功能的调用逻辑已被整合在get_pte()中，鉴于它们之间紧密的关联性，我认为应该维持这种结构，没有必要将两个功能拆开。


### 练习3：给未被映射的地址映射上物理页（需要编程）
补充完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
 - 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。
 - 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
- 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

#### 设计实现过程

在本次实验中，我们需要补充完成 `do_pgfault` 函数，该函数用于处理缺页异常。目标是将未映射的地址映射到物理页，确保在缺页异常发生时系统能够正确地为缺失的页分配物理内存，并建立虚拟地址到物理地址的映射。在具体实现过程中，我采取了以下步骤：

1. **查找对应的 VMA (Virtual Memory Area)**：首先通过 `find_vma` 函数查找包含导致缺页异常的地址的 VMA 结构体。如果找不到对应的 VMA，说明访问的地址无效，此时返回错误。

2. **判断 VMA 权限并设置页表项权限**：根据 VMA 的访问权限设置页表项权限 (`perm`)。如果 VMA 的权限允许写操作，则设置页表项的可写权限。

3. **向下取整页对齐地址**：将导致缺页异常的地址向下取整为页大小对齐，以便于进行页表项操作。

4. **获取页表项**：使用 `get_pte` 函数获取页表项指针，如果对应的页表不存在，则创建一个新的页表。通过 `get_pte` 获取页表项指针，确保可以对缺页地址进行映射操作。

5. **分配物理页并建立映射**：
   - 如果页表项为零，说明该地址未被映射到物理页，此时调用 `pgdir_alloc_page` 分配一个物理页并建立物理地址与线性地址的映射。
   - 如果页表项不为零且指向一个交换条目，则需要从磁盘中加载该页。调用 `swap_in` 函数将页面从磁盘加载到内存，之后使用 `page_insert` 建立物理页和逻辑地址之间的映射，并调用 `swap_map_swappable` 将该页面设置为可交换，以便后续进行页面置换管理。

补充代码如下所示：
```C++
if (swap_init_ok) {
            struct Page *page = NULL;
            // 你要编写的内容在这里，请基于上文说明以及下文的英文注释完成代码编写
            //(1）According to the mm AND addr, try
            //to load the content of right disk page
            //into the memory which page managed.
            if (swap_in(mm, addr, &page) != 0) {
                cprintf("swap_in failed\n");
                goto failed;
            }
            //(2) According to the mm,
            //addr AND page, setup the
            //map of phy addr <--->
            //logical addr
            if (page_insert(mm->pgdir, page, addr, perm) != 0) {
                cprintf("page_insert failed\n");
                goto failed;
            }
            //(3) make the page swappable.
            swap_map_swappable(mm, addr, page, 1);
            page->pra_vaddr = addr;
        } else {
            cprintf("no swap_init_ok but ptep is %x, failed\n", *ptep);
            goto failed;
        }
```

#### 问题回答

1. **页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对 uCore 实现页替换算法的潜在用处**
   
   页目录项和页表项在页替换算法中的作用主要是提供虚拟地址到物理地址的映射关系。当发生缺页异常时，系统通过页目录项和页表项找到对应的物理页或交换条目。如果页表项指向一个交换条目（即页面不在内存中而是在磁盘上），页替换算法会将对应的页从磁盘中加载到内存中，并更新页表项，使其指向新的物理页地址。因此，页目录项和页表项不仅用于地址转换，还用于管理页面在内存和磁盘之间的状态。

2. **如果 uCore 的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？**

   当缺页服务例程访问内存时出现页访问异常，硬件会执行以下步骤：
   - 将引起异常的线性地址存入 `CR2` 寄存器（在 RISC-V 中为 `stval` 寄存器），以便操作系统获取该地址。
   - 生成一个错误码，并将其压入当前栈中。错误码包含引起异常的原因（例如页面不存在、访问权限错误等）。
   - 通过中断或异常处理机制，硬件会切换到内核模式，并跳转到操作系统的页故障处理例程进行处理。

3. **数据结构 `Page` 的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？**

   `Page` 数据结构的每一项与页表中的页目录项和页表项存在对应关系。具体来说，`Page` 结构体描述了物理内存中的每一页，其包含的字段用于记录该页的引用计数、标志位、虚拟地址等信息。当一个页表项指向某个物理页时，该物理页由 `Page` 结构体中的一个元素表示。因此，页表项中的物理地址字段可以通过一定的转换（例如通过页帧号）找到对应的 `Page` 结构体，从而获取该物理页的相关信息。`Page` 结构体的 `pra_vaddr` 字段也可以帮助记录该物理页对应的虚拟地址，用于页替换算法中的管理。


### 练习4：补充完成Clock页替换算法（需要编程）
通过之前的练习，相信大家对FIFO的页面替换算法有了更深入的了解，现在请在我们给出的框架上，填写代码，实现 Clock页替换算法（mm/swap_clock.c）。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
 - 比较Clock页替换算法和FIFO算法的不同。

**实现过程**：

完成如下各个函数;

- **_clock_init_mm**

```c
static int
_clock_init_mm(struct mm_struct *mm)
{     
     /*LAB3 EXERCISE 4: 2210554*/ 
     // 初始化pra_list_head为空链表
     list_init(&pra_list_head);
     // 初始化当前指针curr_ptr指向pra_list_head，表示当前页面替换位置为链表头
     curr_ptr = &pra_list_head;
     // 将mm的私有成员指针指向pra_list_head，用于后续的页面替换算法操作
     mm->sm_priv = &pra_list_head;
     //cprintf(" mm->sm_priv %x in fifo_init_mm\n",mm->sm_priv);
     return 0;
}
```

使用list_init初始化pra_list_head为空链表，然后令curr_ptr指向表头，将mm的私有成员指针sm_priv指向pra_list_head即可。

- **_clock_map_swappable**

```c
static int
_clock_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
{
    list_entry_t *entry=&(page->pra_page_link);
 
    assert(entry != NULL && curr_ptr != NULL);
    //record the page access situlation
    /*LAB3 EXERCISE 4: 2210554*/ 
    // link the most recent arrival page at the back of the pra_list_head qeueue.
    // 将页面page插入到页面链表pra_list_head的末尾
    list_entry_t *head=(list_entry_t*) mm->sm_priv;
    list_add_before(head, entry);
    // 将页面的visited标志置为1，表示该页面已被访问
    page->visited = 1;
    return 0;
}
```

根据提示将page插入到head前面即链表的末尾，然后将visited标志置为1，表示该页面已被访问。

- **_clock_swap_out_victim**

```c
static int
_clock_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)
{
     list_entry_t *head=(list_entry_t*) mm->sm_priv;
         assert(head != NULL);
     assert(in_tick==0);
     /* Select the victim */
     //(1)  unlink the  earliest arrival page in front of pra_list_head qeueue
     //(2)  set the addr of addr of this page to ptr_page
    while (1) {
        /*LAB3 EXERCISE 4: YOUR CODE：2212850*/ 
        // 编写代码
        // 遍历页面链表pra_list_head，查找最早未被访问的页面
        // 获取当前页面对应的Page结构指针
        // 如果当前页面未被访问，则将该页面从页面链表中删除，并将该页面指针赋值给ptr_page作为换出页面
        // 如果当前页面已被访问，则将visited标志置为0，表示该页面已被重新访问
        if (curr_ptr == &pra_list_head || curr_ptr == NULL) {
            curr_ptr = list_next(&pra_list_head);
            //cprintf("curr_ptr %p \n", curr_ptr);
        }
        
        struct Page *page = le2page(curr_ptr, pra_page_link);
        if (page->visited == 0) {
            *ptr_page = page;
            cprintf("curr_ptr %p\n", curr_ptr);
            list_del(curr_ptr);
            cprintf("curr_ptr %p \n", curr_ptr);
            curr_ptr = list_next(curr_ptr);

            break;
        } else {
            page->visited = 0; // Clear the accessed bit
            curr_ptr = list_next(curr_ptr);
        
        }
    }
    return 0;
}
```


回答如下问题：

• **比较 Clock 页替换算法和 FIFO 算法的不同。**

**答**：

- 先进先出 (First In First Out, FIFO) 页替换算法：该算法总是淘汰最先进入内存的页，即选择在内存中驻

	留时间最久的页予以淘汰。只需把一个应用程序在执行过程中已调入内存的页按先后次序链接成一个

	队列，队列头指向内存中驻留时间最久的页，队列尾指向最近被调入内存的页。这样需要淘汰页时，从

	队列头很容易查找到需要淘汰的页。FIFO 算法只是在应用程序按线性顺序访问地址空间时效果才好，

	否则效率不高。**因为那些常被访问的页，往往在内存中也停留得最久**，结果它们因变“老”而不得不

	被置换出去。FIFO 算法的另一个缺点是，它有一种**异常现象（Belady 现象）**，即在增加放置页的物理页

	帧的情况下，反而使页访问异常次数增多。

- 时钟（Clock）页替换算法：是 LRU 算法的一种近似实现。时钟页替换算法把各个页面组织成环形链表

	的形式，类似于一个钟的表面。然后把一个指针（简称当前指针）指向最老的那个页面，即最先进来

	的那个页面。另外，时钟算法需要在页表项（PTE）中设置了一位访问位来表示此页表项对应的页当前

	**是否被访问过**。当该页被访问时，CPU 中的 MMU 硬件将把访问位置“1”。当操作系统需要淘汰页时，

	对当前指针指向的页所对应的页表项进行查询，如果访问位为“0”，则淘汰该页，如果该页被写过，则

	还要把它换出到硬盘上；如果访问位为“1”，则将该页表项的此位置“0”，继续访问下一个页。该算法

	近似地体现了 LRU 的思想，且易于实现，开销少，需要硬件支持来设置访问位。时钟页替换算法在本

	质上与 FIFO 算法是类似的，不同之处是在时钟页替换算法中跳过了访问位为 1 的页。

*总而言之，CLOCK算法考虑了页表项表示的页是否被访问过，而FIFO不考虑这点。*

### 练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）
如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？

#### 分级页表映射
分级页表是一种将虚拟地址空间分割为多个层级（如页目录、页表、页表项）的映射方式。常见的分级页表有 **二级页表**、**三级页表** 或更复杂的结构。这种结构将虚拟地址空间分割成多个小块，每个块的映射关系由页目录和页表项来表示。

##### 优点：
1. **内存高效利用**：
   - 分级页表可以根据需要分配内存，避免了为整个虚拟地址空间分配页表空间。在进程的虚拟地址空间不完全使用时，只有需要的部分才会有对应的页表项，从而节省了内存。
   
2. **虚拟地址空间更大**：
   - 分级页表允许在更大的虚拟地址空间上工作，可以轻松支持几 GB 或 TB 的虚拟内存空间。例如，Intel x86_64 架构使用四级页表来支持 48 位虚拟地址空间，能访问 256TB 的虚拟内存。
   
3. **灵活的映射**：
   - 可以通过分级结构灵活地管理内存，支持不同大小的页面，能够根据不同的使用场景，调整每层的页大小或映射策略。

4. **防止碎片化**：
   - 由于分级页表的映射是按需创建的，所以在内存分配时，能够较好地避免内存碎片的问题。

##### 缺点：
1. **多级查找开销**：
   - 由于分级页表是分多个层次存储的，每次进行虚拟地址到物理地址的转换时，需要通过多个页目录和页表项，增加了查找的开销，尤其是当页表层级较多时。
   
2. **分页表的维护成本**：
   - 页表本身需要进行维护，尤其是在需要频繁更新映射关系的情况下，可能会带来额外的计算和存储开销。

3. **TLB 缺失带来的性能问题**：
   - 每次访问内存时，可能会频繁出现 TLB 缺失，导致需要多次访问内存中的页表项，影响性能。

#### "一个大页" 映射方式

在“一个大页”的映射方式中，虚拟地址空间的一部分或全部都映射到一个较大的物理页面上（比如 2MB、1GB 等），不再使用常规的 4KB 页面。

##### 优点：
1. **减少页表项**：
   - 使用大页可以显著减少页表项的数量。由于每个大页映射的虚拟地址范围远大于普通小页，因此，映射一个大页只需要一个页表项，减少了页表的大小，减少了内存的消耗。
   
2. **减少TLB的缺失**：
   - 大页意味着每个页面可以覆盖更多的虚拟地址，这有助于减少 TLB 缺失的频率，提高访问速度。更少的页表项也减少了查找页表的时间，从而提高了内存访问的效率。

3. **减少内存碎片**：
   - 由于大页可以映射较大块的内存区域，因此可以减少内存碎片。特别是在大规模内存密集型应用中，大页的使用能够减少页面的分散存储，提高内存利用率。

4. **支持大规模数据处理**：
   - 对于一些需要大量内存空间的应用，如数据库、大型科学计算、大数据处理等，使用大页有助于提升整体性能和计算效率。

##### 缺点：
1. **内存浪费**：
   - 如果虚拟内存空间中的大部分页面并没有被使用，使用大页可能导致内存浪费。例如，如果程序只访问了某些小范围的内存区域，但却分配了一个很大的页面，剩余的部分就会空闲。
   
2. **缺乏灵活性**：
   - 大页在映射时会占用较大连续空间，因此系统可能难以在页表中分配足够大的连续空间，导致系统灵活性较差。相比于分级页表的按需分配，使用大页时可能会对内存管理造成一定压力。
   
3. **对内存碎片的敏感性**：
   - 大页要求物理内存必须能够提供连续的空间，如果内存中存在碎片（即较小的未分配空间无法满足大页的要求），则可能导致无法分配足够的内存来满足大页的需求。

4. **硬件/操作系统支持要求高**：
   - 许多硬件和操作系统需要专门支持大页管理。如果硬件的 TLB 或 MMU（内存管理单元）不支持大页，系统的性能优势就会大大降低。
   
5. **管理开销**：
   - 尽管大页减少了页表的大小，但操作系统仍然需要在一些情况下对大页进行管理，这可能需要额外的开销，尤其是在使用大页进行动态内存分配时。

#### 比较总结

| 特性                | 分级页表 | 一个大页               |
|---------------------|----------------------------------|------------------------------------|
| **内存利用效率**      | 高，按需分配，节省内存              | 较低，可能浪费内存                  |
| **性能**             | 查询页表时有一定的开销，尤其是多级页表 | 查询页表时较少，TLB缺失较少，提高性能 |
| **内存碎片**         | 较少                              | 如果页面没有被完全使用，则会浪费内存 |
| **适用场景**         | 一般应用，支持灵活映射               | 内存密集型应用，如数据库、大规模计算 |
| **硬件支持要求**     | 较低，几乎所有硬件支持              | 需要硬件和操作系统的专门支持         |

#### 结论

- **分级页表** 适合于需要灵活地址映射、内存使用不完全连续或不规则的场景。它可以提供较好的内存管理效率和较低的内存碎片，但查询页表时存在一定的开销。
- **一个大页** 更适合需要高性能、内存密集型应用，如大型数据库、科学计算等。它能够减少页表项，减少 TLB 缺失带来的性能损失，但也存在内存浪费和碎片化的问题。

