# Lab3：缺页异常和页面置换
## 2213781 宋宣昊
### 练习1：理解基于FIFO的页面替换算法（思考题）
描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？（为了方便同学们完成练习，所以实际上我们的项目代码和实验指导的还是略有不同，例如我们将FIFO页面置换算法头文件的大部分代码放在了`kern/mm/swap_fifo.c`文件中，这点请同学们注意）
 - 至少正确指出10个不同的函数分别做了什么？如果少于10个将酌情给分。我们认为只要函数原型不同，就算两个不同的函数。要求指出对执行过程有实际影响,删去后会导致输出结果不同的函数（例如assert）而不是cprintf这样的函数。如果你选择的函数不能完整地体现”从换入到换出“的过程，比如10个函数都是页面换入的时候调用的，或者解释功能的时候只解释了这10个函数在页面换入时的功能，那么也会扣除一定的分数

### 练习2：深入理解不同分页模式的工作原理（思考题）
get_pte()函数（位于`kern/mm/pmm.c`）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
 - get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
 - 目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

### 练习3：给未被映射的地址映射上物理页（需要编程）
补充完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
 - 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。
 - 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
- 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

#### 设计实现过程

在本次实验中，我们需要补充完成 `do_pgfault` 函数，该函数用于处理缺页异常。目标是将未映射的地址映射到物理页，确保在缺页异常发生时系统能够正确地为缺失的页分配物理内存，并建立虚拟地址到物理地址的映射。在具体实现过程中，我采取了以下步骤：

1. **查找对应的 VMA (Virtual Memory Area)**：首先通过 `find_vma` 函数查找包含导致缺页异常的地址的 VMA 结构体。如果找不到对应的 VMA，说明访问的地址无效，此时返回错误。

2. **判断 VMA 权限并设置页表项权限**：根据 VMA 的访问权限设置页表项权限 (`perm`)。如果 VMA 的权限允许写操作，则设置页表项的可写权限。

3. **向下取整页对齐地址**：将导致缺页异常的地址向下取整为页大小对齐，以便于进行页表项操作。

4. **获取页表项**：使用 `get_pte` 函数获取页表项指针，如果对应的页表不存在，则创建一个新的页表。通过 `get_pte` 获取页表项指针，确保可以对缺页地址进行映射操作。

5. **分配物理页并建立映射**：
   - 如果页表项为零，说明该地址未被映射到物理页，此时调用 `pgdir_alloc_page` 分配一个物理页并建立物理地址与线性地址的映射。
   - 如果页表项不为零且指向一个交换条目，则需要从磁盘中加载该页。调用 `swap_in` 函数将页面从磁盘加载到内存，之后使用 `page_insert` 建立物理页和逻辑地址之间的映射，并调用 `swap_map_swappable` 将该页面设置为可交换，以便后续进行页面置换管理。

补充代码如下所示：
```C++
if (swap_init_ok) {
            struct Page *page = NULL;
            // 你要编写的内容在这里，请基于上文说明以及下文的英文注释完成代码编写
            //(1）According to the mm AND addr, try
            //to load the content of right disk page
            //into the memory which page managed.
            if (swap_in(mm, addr, &page) != 0) {
                cprintf("swap_in failed\n");
                goto failed;
            }
            //(2) According to the mm,
            //addr AND page, setup the
            //map of phy addr <--->
            //logical addr
            if (page_insert(mm->pgdir, page, addr, perm) != 0) {
                cprintf("page_insert failed\n");
                goto failed;
            }
            //(3) make the page swappable.
            swap_map_swappable(mm, addr, page, 1);
            page->pra_vaddr = addr;
        } else {
            cprintf("no swap_init_ok but ptep is %x, failed\n", *ptep);
            goto failed;
        }
```

#### 问题回答

1. **页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对 uCore 实现页替换算法的潜在用处**
   
   页目录项和页表项在页替换算法中的作用主要是提供虚拟地址到物理地址的映射关系。当发生缺页异常时，系统通过页目录项和页表项找到对应的物理页或交换条目。如果页表项指向一个交换条目（即页面不在内存中而是在磁盘上），页替换算法会将对应的页从磁盘中加载到内存中，并更新页表项，使其指向新的物理页地址。因此，页目录项和页表项不仅用于地址转换，还用于管理页面在内存和磁盘之间的状态。

2. **如果 uCore 的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？**

   当缺页服务例程访问内存时出现页访问异常，硬件会执行以下步骤：
   - 将引起异常的线性地址存入 `CR2` 寄存器（在 RISC-V 中为 `stval` 寄存器），以便操作系统获取该地址。
   - 生成一个错误码，并将其压入当前栈中。错误码包含引起异常的原因（例如页面不存在、访问权限错误等）。
   - 通过中断或异常处理机制，硬件会切换到内核模式，并跳转到操作系统的页故障处理例程进行处理。

3. **数据结构 `Page` 的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？**

   `Page` 数据结构的每一项与页表中的页目录项和页表项存在对应关系。具体来说，`Page` 结构体描述了物理内存中的每一页，其包含的字段用于记录该页的引用计数、标志位、虚拟地址等信息。当一个页表项指向某个物理页时，该物理页由 `Page` 结构体中的一个元素表示。因此，页表项中的物理地址字段可以通过一定的转换（例如通过页帧号）找到对应的 `Page` 结构体，从而获取该物理页的相关信息。`Page` 结构体的 `pra_vaddr` 字段也可以帮助记录该物理页对应的虚拟地址，用于页替换算法中的管理。


### 练习4：补充完成Clock页替换算法（需要编程）
通过之前的练习，相信大家对FIFO的页面替换算法有了更深入的了解，现在请在我们给出的框架上，填写代码，实现 Clock页替换算法（mm/swap_clock.c）。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
 - 比较Clock页替换算法和FIFO算法的不同。

### 练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）
如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？

#### 分级页表映射
分级页表是一种将虚拟地址空间分割为多个层级（如页目录、页表、页表项）的映射方式。常见的分级页表有 **二级页表**、**三级页表** 或更复杂的结构。这种结构将虚拟地址空间分割成多个小块，每个块的映射关系由页目录和页表项来表示。

##### 优点：
1. **内存高效利用**：
   - 分级页表可以根据需要分配内存，避免了为整个虚拟地址空间分配页表空间。在进程的虚拟地址空间不完全使用时，只有需要的部分才会有对应的页表项，从而节省了内存。
   
2. **虚拟地址空间更大**：
   - 分级页表允许在更大的虚拟地址空间上工作，可以轻松支持几 GB 或 TB 的虚拟内存空间。例如，Intel x86_64 架构使用四级页表来支持 48 位虚拟地址空间，能访问 256TB 的虚拟内存。
   
3. **灵活的映射**：
   - 可以通过分级结构灵活地管理内存，支持不同大小的页面，能够根据不同的使用场景，调整每层的页大小或映射策略。

4. **防止碎片化**：
   - 由于分级页表的映射是按需创建的，所以在内存分配时，能够较好地避免内存碎片的问题。

##### 缺点：
1. **多级查找开销**：
   - 由于分级页表是分多个层次存储的，每次进行虚拟地址到物理地址的转换时，需要通过多个页目录和页表项，增加了查找的开销，尤其是当页表层级较多时。
   
2. **分页表的维护成本**：
   - 页表本身需要进行维护，尤其是在需要频繁更新映射关系的情况下，可能会带来额外的计算和存储开销。

3. **TLB 缺失带来的性能问题**：
   - 每次访问内存时，可能会频繁出现 TLB 缺失，导致需要多次访问内存中的页表项，影响性能。

#### "一个大页" 映射方式

在“一个大页”的映射方式中，虚拟地址空间的一部分或全部都映射到一个较大的物理页面上（比如 2MB、1GB 等），不再使用常规的 4KB 页面。

##### 优点：
1. **减少页表项**：
   - 使用大页可以显著减少页表项的数量。由于每个大页映射的虚拟地址范围远大于普通小页，因此，映射一个大页只需要一个页表项，减少了页表的大小，减少了内存的消耗。
   
2. **减少TLB的缺失**：
   - 大页意味着每个页面可以覆盖更多的虚拟地址，这有助于减少 TLB 缺失的频率，提高访问速度。更少的页表项也减少了查找页表的时间，从而提高了内存访问的效率。

3. **减少内存碎片**：
   - 由于大页可以映射较大块的内存区域，因此可以减少内存碎片。特别是在大规模内存密集型应用中，大页的使用能够减少页面的分散存储，提高内存利用率。

4. **支持大规模数据处理**：
   - 对于一些需要大量内存空间的应用，如数据库、大型科学计算、大数据处理等，使用大页有助于提升整体性能和计算效率。

##### 缺点：
1. **内存浪费**：
   - 如果虚拟内存空间中的大部分页面并没有被使用，使用大页可能导致内存浪费。例如，如果程序只访问了某些小范围的内存区域，但却分配了一个很大的页面，剩余的部分就会空闲。
   
2. **缺乏灵活性**：
   - 大页在映射时会占用较大连续空间，因此系统可能难以在页表中分配足够大的连续空间，导致系统灵活性较差。相比于分级页表的按需分配，使用大页时可能会对内存管理造成一定压力。
   
3. **对内存碎片的敏感性**：
   - 大页要求物理内存必须能够提供连续的空间，如果内存中存在碎片（即较小的未分配空间无法满足大页的要求），则可能导致无法分配足够的内存来满足大页的需求。

4. **硬件/操作系统支持要求高**：
   - 许多硬件和操作系统需要专门支持大页管理。如果硬件的 TLB 或 MMU（内存管理单元）不支持大页，系统的性能优势就会大大降低。
   
5. **管理开销**：
   - 尽管大页减少了页表的大小，但操作系统仍然需要在一些情况下对大页进行管理，这可能需要额外的开销，尤其是在使用大页进行动态内存分配时。

#### 比较总结

| 特性                | 分级页表 | 一个大页               |
|---------------------|----------------------------------|------------------------------------|
| **内存利用效率**      | 高，按需分配，节省内存              | 较低，可能浪费内存                  |
| **性能**             | 查询页表时有一定的开销，尤其是多级页表 | 查询页表时较少，TLB缺失较少，提高性能 |
| **内存碎片**         | 较少                              | 如果页面没有被完全使用，则会浪费内存 |
| **适用场景**         | 一般应用，支持灵活映射               | 内存密集型应用，如数据库、大规模计算 |
| **硬件支持要求**     | 较低，几乎所有硬件支持              | 需要硬件和操作系统的专门支持         |

#### 结论

- **分级页表** 适合于需要灵活地址映射、内存使用不完全连续或不规则的场景。它可以提供较好的内存管理效率和较低的内存碎片，但查询页表时存在一定的开销。
- **一个大页** 更适合需要高性能、内存密集型应用，如大型数据库、科学计算等。它能够减少页表项，减少 TLB 缺失带来的性能损失，但也存在内存浪费和碎片化的问题。

