# Lab5：用户程序
## 2213781 宋宣昊  2210554 刘志威   2212850 王海鹏

## 练习1: 加载应用程序并执行
**do_execv**函数调用`load_icode`（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序。你需要补充`load_icode`的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好`proc_struct`结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。

请在实验报告中简要说明你的设计实现过程。
- 请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

### 设计实现过程
#### 补充alloc_proc函数中新增的变量的初始化
补充代码如下：
```cpp
proc->wait_state = 0;
proc->cptr = NULL;
proc->yptr = NULL;
proc->optr = NULL;
```
#### 更新do_fork代码
更新代码如下：
```cpp
proc = alloc_proc();
if (proc == NULL) {
    goto bad_fork_cleanup_proc;
}
proc->parent = current;
// 2. 调用 setup_kstack 为子进程分配内核栈
if (setup_kstack(proc) != 0) {
    goto bad_fork_cleanup_proc;
}

// 3. 判断是否需要复制内存管理信息

    
if (copy_mm(clone_flags, proc) != 0) {
    goto bad_fork_cleanup_kstack;
}


// 4. 调用 copy_thread 设置 tf 和 context
copy_thread(proc, stack, tf);

// 5. 将新进程加入哈希链和进程列表

proc->pid = get_pid();
hash_proc(proc);
set_links(proc);
// 6. 调用 wakeup_proc 将新进程置为可调度
wakeup_proc(proc);

// 7. 设置返回值为子进程的 PID
ret = proc->pid;
```

#### 补充`load_icode`的第6步代码
补充代码如下：
```cpp
tf->gpr.sp = USTACKTOP;// 设置用户栈指针
tf->epc = elf->e_entry;// 设置程序计数器为 ELF 入口地址
tf->status = (read_csr(sstatus) & ~SSTATUS_SPP) | SSTATUS_SPIE;
// 配置状态寄存器，确保用户态执行环境
```
`trapframe` 结构用于保存进程在陷入内核态时的上下文信息，包括通用寄存器、程序计数器 (`epc`)、栈指针 (`sp`)、状态寄存器 (`status`) 等。为了确保进程能够正确从用户态开始执行，需要在 `trapframe` 中正确设置以下内容：
- **栈指针 (`sp`)**：指向用户栈的顶部，即 `USTACKTOP`。
- **程序计数器 (`epc`)**：设置为 ELF 文件的入口地址 (`e_entry`)。
- **状态寄存器 (`status`)**：配置为适当的用户模式状态，设置 `SPP` 为用户模式，启用中断 (`SPIE`)，禁用用户态中断 (`SIE`)。

通过上述代码，我正确设置了`trapframe`，保证了：
- 栈指针指向用户栈顶，保证用户程序的栈操作能够正确进行。
- 程序计数器指向用户程序的入口地址，确保执行从正确的位置开始。
- 状态寄存器配置为用户模式，并启用中断，确保用户程序能够正常响应中断。

#### 执行流程描述
##### 1. 进程创建与初始化

**1.1 调用 `do_execve` 系统调用**

- 用户程序通过 `execve` 系统调用请求执行一个新的应用程序。
- `do_execve` 函数被内核调用，负责加载并执行新的应用程序。

**1.2 加载应用程序到内存 (`load_icode`)**

- `do_execve` 调用 `load_icode` 函数，将位于内存中的ELF格式的二进制文件加载到当前进程的地址空间。
- `load_icode` 完成以下关键步骤：
  - 创建并初始化新的内存管理结构 (`mm_struct`)。
  - 设置页目录 (`pgdir`)，复制内核的页目录表。
  - 解析ELF头，加载各个程序段（如代码段、数据段）到内存，并处理BSS段（未初始化的数据）。
  - 构建用户栈内存。
  - 设置 `trapframe` 结构，配置用户栈指针 (`sp`)、程序计数器 (`epc`)、状态寄存器 (`status`) 等，确保进程能够从指定的入口地址开始执行。

**1.3 设置进程状态为可运行**

- 加载完成后，`do_execve` 将当前进程的状态设置为 `PROC_RUNNABLE`，表示该进程已准备好被调度器选择执行。

##### 2. 调度器选择进程

**2.1 调用 `proc_run` 函数**

- 调度器在选择下一个运行的进程时，若选择当前进程，则无需切换。
- 若选择其他进程，则调用 `proc_run` 函数将选中的进程切换为当前运行进程。

**2.2 切换到新进程**
```c
void proc_run(struct proc_struct *proc) {
    if (proc != current) {
        bool intr_flag;
        struct proc_struct *prev = current, *next = proc;
        local_intr_save(intr_flag); // 禁用中断并保存中断状态
        {
            current = proc; // 更新当前运行进程指针
            lcr3(next->cr3); // 切换到新进程的页目录基地址
            switch_to(&(prev->context), &(next->context)); // 上下文切换
        }
        local_intr_restore(intr_flag); // 恢复中断状态
    }
}
```

- **禁用中断**：确保上下文切换过程的原子性，防止中断打断切换过程。
- **更新当前进程指针**：将 `current` 指向即将运行的进程。
- **切换页目录 (`lcr3`)**：加载新进程的页目录基地址，确保地址空间正确。
- **上下文切换 (`switch_to`)**：
  - 保存当前进程的上下文（寄存器状态等）。
  - 恢复新进程的上下文，使CPU寄存器恢复到新进程的状态。
- **恢复中断**：允许中断的再次发生。

##### 3. 从内核态切换到用户态

**3.1 恢复用户态上下文**

- 上下文切换完成后，CPU寄存器状态恢复到新进程的 `trapframe` 中保存的状态。
- 关键寄存器包括：
  - **程序计数器 (`epc`)**：指向用户程序的入口地址。
  - **栈指针 (`sp`)**：指向用户栈的顶部。
  - **状态寄存器 (`status`)**：配置为用户模式，启用中断等。

**3.2 执行 `sret` 指令**

- `sret`（Supervisor Return）指令用于从内核态返回到用户态。
- 执行 `sret` 后，CPU根据 `trapframe` 中保存的状态寄存器和程序计数器，切换到用户态并跳转到用户程序的入口地址。

##### 4. 用户程序开始执行

**4.1 从入口地址执行第一条指令**

- 用户程序从 `trapframe->epc` 指定的入口地址开始执行。
- 由于 `trapframe->sp` 已正确设置为用户栈顶，用户程序能够正确进行栈操作。
- 状态寄存器配置为用户模式，确保程序在用户态下运行，并具备必要的权限和中断处理能力。


##### 总结

1. **进程创建与加载**：
   - 通过 `do_execve` 和 `load_icode`，将用户程序加载到内存，并设置初始执行环境。
   - 将进程状态设置为 `PROC_RUNNABLE`。

2. **调度器选择进程**：
   - 调度器选择 `PROC_RUNNABLE` 状态的进程，并调用 `proc_run` 进行上下文切换。

3. **上下文切换与模式切换**：
   - 禁用中断，切换页目录，保存和恢复上下文。
   - 执行 `sret` 指令，从内核态切换到用户态。

4. **用户程序执行**：
   - 用户程序从入口地址开始执行，进入用户态的正常运行流程。



## 练习2: 父进程复制自己的内存空间给子进程
创建子进程的函数`do_fork`在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过`copy_range`函数（位于kern/mm/pmm.c中）实现的，请补充`copy_range`的实现，确保能够正确执行。

请在实验报告中简要说明你的设计实现过程。

- 如何设计实现`Copy on Write`机制？给出概要设计，鼓励给出详细设计。

> Copy-on-write（简称COW）的基本概念是指如果有多个使用者对一个资源A（比如内存块）进行读操作，则每个使用者只需获得一个指向同一个资源A的指针，就可以该资源了。若某使用者需要对这个资源A进行写操作，系统会对该资源进行拷贝操作，从而使得该“写操作”使用者获得一个该资源A的“私有”拷贝—资源B，可对资源B进行写操作。该“写操作”使用者对资源B的改变对于其他的使用者而言是不可见的，因为其他使用者看到的还是资源A。

## 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现
请在实验报告中简要说明你对 fork/exec/wait/exit函数的分析。并回答如下问题：
- 请分析fork/exec/wait/exit的执行流程。重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核态与用户态程序是如何交错执行的？内核态执行结果是如何返回给用户程序的？
- 请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）

执行：make grade。如果所显示的应用程序检测都输出ok，则基本正确。（使用的是qemu-1.0.1）

## 扩展练习 Challenge
### 说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？
#### `uCore`中用户程序的预加载时机

在`uCore`中，用户程序通常是**在内核编译阶段预先嵌入到内核映像中**，而不是在运行时从文件系统中加载。这种预加载方式主要通过以下几个步骤实现：

1. **编译阶段嵌入**：
   - 用户程序（如 `exit`、`test` 等）在编译时被编译为二进制文件，并作为静态数据嵌入到内核的可执行文件中。
   - 通过链接器脚本或特定的编译选项，将用户程序的二进制数据（如 `_binary_obj___user_exit_out_start`）包含在内核映像中。

2. **加载到内存**：
   - 在内核启动过程中，这些嵌入的用户程序数据被加载到内存的特定区域。
   - 当调用 `do_execve` 系统调用时，`load_icode` 函数直接从内存中提取这些预先嵌入的二进制数据，解析并加载到用户进程的地址空间中。

3. **执行用户程序**：
   - 通过设置 `trapframe` 结构，用户程序的入口地址被正确配置，确保进程能够从指定的起始地址开始执行。

#### 与常用操作系统加载机制的区别

**1. 加载时机和来源不同**：

- **uCore**：
  - 用户程序在**内核编译阶段**就被预先嵌入到内核映像中。
  - 加载时直接从内存中的静态数据中提取，无需文件系统支持。
  
- **常用操作系统（如Linux、Windows）**：
  - 用户程序存储在**文件系统**中（如磁盘上的可执行文件）。
  - 加载时，通过文件系统接口读取磁盘上的二进制文件，将其加载到内存中。

**2. 灵活性和扩展性**：

- **uCore**：
  - 由于用户程序是预先嵌入到内核中，**添加或修改用户程序需要重新编译内核**。
  - 适用于教学环境，简化操作系统的实现，避免实现完整的文件系统支持。
  
- **常用操作系统**：
  - 用户程序可以**动态地添加、删除和修改**，不需要重新编译内核。
  - 支持复杂的文件系统和动态加载机制，提高了系统的灵活性和用户体验。

**3. 复杂度和功能实现**：

- **uCore**：
  - **简化了加载过程**，不需要实现文件系统、磁盘管理、路径解析等复杂功能。
  - 适用于教学目的，重点在于理解进程管理、内存管理和系统调用等核心概念。
  
- **常用操作系统**：
  - 需要实现**完整的加载机制**，包括文件系统支持、虚拟内存管理、动态链接库等。
  - 提供更强大的功能和更高的用户友好性，适用于实际应用和生产环境。

#### 设计选择的原因

**1. 教学目的**：
uCore作为一个教学操作系统，旨在帮助学生理解操作系统的基本概念和机制。通过预先嵌入用户程序，可以**简化实验环境**，让学生专注于核心内容，如进程管理、内存管理和系统调用，而无需处理文件系统的复杂性。

**2. 实现简便**：
预先嵌入用户程序避免了实现文件系统、磁盘驱动等复杂模块。这使得操作系统的实现更加**简洁和直观**，适合在有限的实验时间内完成。

**3. 固定程序集**：
在教学环境中，通常只需要一组固定的用户程序来演示和测试操作系统功能。预先嵌入这些程序可以确保实验的一致性和可控性，避免学生在实验过程中遇到不必要的加载问题。




